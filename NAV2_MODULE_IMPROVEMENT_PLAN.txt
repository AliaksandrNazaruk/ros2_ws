NAV2 Module Improvement Plan (AE.HUB / aehub_navigation)
Date: 2026-01-15

E2E chain run (FakeHub -> MQTT -> navigation_integrated_node -> Nav2 -> /cmd_vel -> base_controller -> motion)
- Command: python3 scripts/e2e_mqtt_to_motion.py --robot-id fahrdummy-01-local --target-id test_position --timeout 45
- Result: FAIL (command accepted, status=navigating, /cmd_vel non-zero seen, but odom distance = 0.0)
- MQTT OK: events ack(received/accepted), status navigation published.
- Nav2 OK: lifecycle ACTIVE for map_server/amcl/planner/controller/bt_navigator.
- Topics OK: /scan, /cmd_vel, /odom exist; TF odom->base_link OK; map->odom exists.
- AMCL pose exists (ros2 topic echo /amcl_pose --once).

Observed behavior
- /cmd_vel is published and non-zero during navigation.
- /odom is published but position does not change during the navigation window.
- Navigation stays in "navigating" state without progress.

Symovo API findings (key)
- GET https://192.168.1.100/v0/agv returns pose but shows:
  - state_flags.drive_ready = false
  - state_flags.drive_manual = true
  - state_flags.charging_connector = true
  - velocity is zero
- Direct PUT /v0/agv/15/move/speed returns HTTP 202 but pose stays unchanged.
=> This strongly suggests the robot is not in a drive-enabled mode (manual/push or on charger),
   so movement commands are accepted but not executed.

Likely causes (most probable first)
1) base_controller does not apply /cmd_vel to the robot hardware (API endpoint not reachable or not executing).
2) /odom comes from a static source or from Symovo API that does not reflect motion (e.g., connection issues).
3) Robot is physically blocked or in an external safety state (estop / hardware stop).
4) Nav2 path generation ok, but controller outputs are too small or filtered by base_controller limits.

Debug steps executed
- check_base_controller_status.py: /odom received (static pose).
- check_nav2_integration.sh: /odom,/cmd_vel,/scan OK; odom->base_link TF OK.
- ros2 node info /base_controller: subscribes /cmd_vel, publishes /odom and /tf.
- tf2_echo map odom: transform present.

Next debugging steps (immediate)
1) Verify base_controller talking to Symovo API (endpoint reachable, amr_id valid).
2) Inspect base_controller logs for API errors and motion command execution.
3) Send direct /cmd_vel once and verify odom changes (manual test).
4) If robot cannot move physically, test with mock_odom_publisher.py to validate Nav2 chain.
5) Confirm target is reachable and far enough to trigger motion.
6) Verify Symovo state_flags allow driving (drive_ready=true, drive_manual=false, charging_connector=false).

Module-level improvements (short-term)
1) Add a "motion watchdog" in navigation_integrated_node:
   - if command accepted but no odom delta and no progress within N seconds, emit NAV_FAILED_TO_MAKE_PROGRESS.
2) Explicitly publish a final status transition to "error" on watchdog timeout.
3) Add structured diagnostics in status payload (last_cmd_vel, odom_delta, controller_timeout).
4) Add a self-check routine on startup:
   - verify /cmd_vel publisher exists and /odom changes over a short time window.
5) Add a "Nav2 readiness report" (map, tf, amcl, controller) on MQTT status/connection topic.

Module-level improvements (mid-term)
1) Separate "hardware readiness" from "navigation readiness" states.
2) Add endpoint checks for Symovo API and include result in system status.
3) Use robust lifecycle management:
   - auto-activate if inactive, report failures.
4) Add E2E regression test script that fails if no motion after accepted goal.
5) Add a scripted "robot move smoke test" to CI (simulated in Gazebo or mocked odom).

Best-practice alignment (robotics)
1) Deterministic goal lifecycle: accepted -> navigating -> arrived/error -> idle.
2) Independent health/diagnostic stream (map, tf, odom, controller status).
3) Safe cancel and timeout handling; always publish terminal result.
4) Clear separation between command validation, navigation execution, and hardware drivers.
5) Consistent logging with command_id correlation across MQTT, Nav2, and base_controller.

Duplicate prevention / anti-ghosting (launch hygiene)
- Problem observed: multiple `ros2 launch ... symovo_nav2.launch.py` instances create duplicate nodes (amcl/map_server/lifecycle_manager/etc),
  leading to invalid contexts and unreliable results.
- Implemented: global stack lock in `src/aehub_navigation/launch/symovo_nav2.launch.py` using `flock` on:
  `/tmp/symovo_nav2_stack.lock`
  If a second launch is attempted, it fails immediately with a clear error and does NOT start any nodes.
- Still recommended operationally:
  - Run the stack via systemd service (single instance) instead of manual multiple terminals.
  - Provide a stop script that kills the stack and removes lock files cleanly.
